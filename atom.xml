<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>YouGuess</title>
  
  <subtitle>youguess13@qq.com</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://yguess.github.io/"/>
  <updated>2017-10-24T08:51:31.246Z</updated>
  <id>https://yguess.github.io/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="https://yguess.github.io/2017/10/26/%E5%AE%BD%E9%AB%98%E8%8E%B7%E5%8F%96%E6%96%B9%E5%BC%8F/"/>
    <id>https://yguess.github.io/2017/10/26/宽高获取方式/</id>
    <published>2017-10-26T01:55:40.843Z</published>
    <updated>2017-10-24T08:51:31.246Z</updated>
    
    <content type="html"><![CDATA[<p>###网页中元素所有的宽、高获取方式</p><blockquote><p>网页可见区域宽：document.body.clientWidth<br>网页可见区域高：document.body.clientHeight<br>网页可见区域宽：document.body.offsetWidth (包括边线的宽)<br>网页可见区域高：document.body.offsetHeight (包括边线的宽)<br>网页正文全文宽：document.body.scrollWidth<br>网页正文全文高：document.body.scrollHeight<br>网页被卷去的高：document.body.scrollTop<br>网页被卷去的左：document.body.scrollLeft<br>网页正文部分上：window.screenTop<br>网页正文部分左：window.screenLeft<br>屏幕分辨率的高：window.screen.height<br>屏幕分辨率的宽：window.screen.width<br>屏幕可用工作区高度：window.screen.availHeight<br>屏幕可用工作区宽度：window.screen.availWidth   </p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;###网页中元素所有的宽、高获取方式&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;网页可见区域宽：document.body.clientWidth&lt;br&gt;网页可见区域高：document.body.clientHeight&lt;br&gt;网页可见区域宽：document.body.o
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://yguess.github.io/2017/10/26/%E5%9D%97%E7%BA%A7%E6%A0%BC%E5%BC%8F%E5%8C%96%E4%B8%8A%E4%B8%8B%E6%96%87/"/>
    <id>https://yguess.github.io/2017/10/26/块级格式化上下文/</id>
    <published>2017-10-26T01:55:40.780Z</published>
    <updated>2016-03-28T06:20:53.369Z</updated>
    
    <content type="html"><![CDATA[<p>#初识块级格式化上下文(Block Formatting Contexts)</p><p>##前言<br>html文档中元素的定位有3种方式(普通流、绝对定位、浮动)，除普通流以外，浮动与绝对定位都会导致元素脱离普通流，按照各自的方式进行定位。<br>带有BFC属性的容器属于普通流的一种。</p><p>##块级格式化上下文 (BFC)<br>块格式化上下文是页面 CSS 视觉渲染的一部分。它是用于决定块盒子的布局及浮动相互影响范围的一个区域。</p><p>BFC是元素在拥有某些特定属性才显示的一种属性，有BFC特性的元素和其他普通流中的元素在样式上没有区别。但在功能上，具有BFC的容器内部与外部隔离，即容器内部的元素不会再布局上影响外部元素。</p><p>有BFC属性的容器可以包含浮动元素、会阻止外边距折叠、可以阻止元素被浮动元素覆盖。</p><p>##如何触发BFC<br>满足下面任意一个条件的元素会触发BFC:</p><blockquote><ul><li>根元素或其它包含它的元素</li><li>浮动 (元素的 float 不为 none)</li><li>绝对定位元素 (元素的 position 为 absolute 或 fixed)</li><li>行内块 inline-blocks (元素的 display: inline-block)</li><li>表格单元格 (元素的 display: table-cell，HTML表格单元格默认属性)</li><li>表格标题 (元素的 display: table-caption, HTML表格标题默认属性)</li><li>overflow 的值不为 visible的元素</li><li>弹性盒 flex boxes (元素的 display: flex 或 inline-flex)</li></ul></blockquote><p>以上是  <a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Block_formatting_context" target="_blank" rel="external">MDN</a> 上引发BFC属性的条件。</p><p>需要注意的是，”display:table” 本身并不产生 BFC，而是由它产生匿名框，匿名框中包含 “display:table-cell” 的框会产 BFC。 总之，对于 “display:table” 的元素，产生 BFC 的是匿名框而不是 “display:table”。</p><p>##BFC特性</p><p>###1. BFC可以包含浮动元素<br>通常，浮动的元素会脱离普通流，不仅会影响兄弟元素，也会影响父容器以及父容器兄弟元素。对于父容器，最直观的就是会使父容器高度塌陷<br><img src="http://img.blog.csdn.net/20160328140223107" alt="未浮动"></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img.blog.csdn.net/20160328140318873" alt="浮动" title="">                </div>                <div class="image-caption">浮动</div>            </figure><p>给父容器添加overflow:hidden属性，使其引起BFC属性.<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img.blog.csdn.net/20160328140822782" alt="这里写图片描述" title="">                </div>                <div class="image-caption">这里写图片描述</div>            </figure></p><p>###2. 阻止外边距折叠<br>两个相连的 div 在垂直上的外边距会发生叠加。<br><br>详细的解释：仅当两个块级元素相邻并且在同一个块级格式化上下文时，它们垂直方向之间的外边距才会叠加。也就是说，即便两个块级元素相邻，但当它们不在同一个块级格式化上下文时它们的边距也不会折叠。因此，阻止外边距折叠只需产生新的 BFC 。</p><p>这里父容器的上下设置了20px的外边距，而p元素有1em的上下外边距。可以看到第一个p元素与父容器顶部没有间距，两者外边距产生重叠。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img.blog.csdn.net/20160328140845422" alt="外边折叠" title="">                </div>                <div class="image-caption">外边折叠</div>            </figure><br>父容器添加overflow:hidden属性，使其引起BFC属性.这里仅第一个p元素与父容器的外边距未折叠，p元素之间外边距折叠。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img.blog.csdn.net/20160328140945576" alt="p元素外边距未折叠" title="">                </div>                <div class="image-caption">p元素外边距未折叠</div>            </figure><br>将中间的p元素用一个div包裹，并添加overflow:hidden属性，使其引起BFC属性.<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img.blog.csdn.net/20160328141148969" alt="这里写图片描述" title="">                </div>                <div class="image-caption">这里写图片描述</div>            </figure></p><p>###3. 阻止元素被浮动元素覆盖<br>上面说过，浮动元素会对兄弟元素造成影响。若兄弟元素是块级元素，则会与浮动元素重叠，位于浮动元素之下。若为内联元素，则依次从左至右排列。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img.blog.csdn.net/20160328141331393" alt="覆盖" title="">                </div>                <div class="image-caption">覆盖</div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img.blog.csdn.net/20160328141351549" alt="未覆盖" title="">                </div>                <div class="image-caption">未覆盖</div>            </figure></p><p>但是若子元素display:inline-block，则子元素宽度之和大于父容器宽度，则最后宽度相加超过父容器宽度的子元素换行显示。</p><p>##BFC处理浮动<br>通常我们清除浮动，方法有几种：</p><ul><li><ol><li>设置空div</li></ol><p>在父容器末尾添加空div,并设置clear:both清除浮动。这样很方便，但违背结构与表象分离的原则。</p></li><li><ol><li>设置overflow </li></ol><p>虽然设置其他属性也能引发BFC属性，但会对布局造成一些影响。设置overflow:hidden的影响相对较小，但在子元素的过大时，超出部分会被覆盖掉，设置auto或scroll又会产生滚动条。</p></li><li><ol><li>:after伪元素 </li></ol><p>通过为容器添加:after伪元素，并给伪元素设置overflow属性，添加IEhack，实现清除浮动。也是网上使用比较多的方法。<br>.clearfix{(<em>zoom: 1;}<br>.clearfix:after{content:’’;height:0;display:block; clear:both;/overflow:hidden;  /\</em>clear,overflow二选其一*/}</p></li></ul><p>##IE6、7下的BFC<br>由于早期IE6、7对于不支持BFC,所以需要通过IEhack解决。在IE6、7中，通过触发hasLayout私有属性实现BFC效果。从使用上看，hasLayout私有属性和BFC触发方式都是通过特有属性触发，IE6、7中大多通过设置zoom:1;触发，zoom用于设置或检索元素缩放比例，值1表示元素实际尺寸，所以设置1不会对元素显示造成影响。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;#初识块级格式化上下文(Block Formatting Contexts)&lt;/p&gt;
&lt;p&gt;##前言&lt;br&gt;html文档中元素的定位有3种方式(普通流、绝对定位、浮动)，除普通流以外，浮动与绝对定位都会导致元素脱离普通流，按照各自的方式进行定位。&lt;br&gt;带有BFC属性的容器
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>js调用百度地图API</title>
    <link href="https://yguess.github.io/2016/03/16/js%E8%B0%83%E7%94%A8%E7%99%BE%E5%BA%A6%E5%9C%B0%E5%9B%BEAPI/"/>
    <id>https://yguess.github.io/2016/03/16/js调用百度地图API/</id>
    <published>2016-03-15T16:00:00.000Z</published>
    <updated>2016-03-16T15:02:12.442Z</updated>
    
    <content type="html"><![CDATA[<p>前几天被要求在页面中调用地图并显示指定地点位置。虽然之前没弄过，但觉的应该很简单，毕竟按着别人的API调用就好。<br>在国内google地图是用不了了，只能选了百度地图。</p><hr><p>首先需要引用百度地图的API<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;http://api.map.baidu.com/api?v=1.3&quot;&gt;&lt;/script&gt;</div></pre></td></tr></table></figure></p><p>此处的v=1.3是指API的版本，目前百度地图API最高是2.0，而且自1.5版本以后的API，调用时需要到 <a href="http://lbsyun.baidu.com/apiconsole/key/create" target="_blank" rel="external">官方申请</a> 一个开发者的密钥，即为</p><pre><code>&lt;script type=&quot;text/javascript&quot; src=&quot;http://api.map.baidu.com/api?v=2.0&amp;ak=您的密钥&quot;&gt;&lt;/script&gt;</code></pre><p>设置1个div用于显示地图，然后再api下开始调用。最后大致如下：</p><pre><code>&lt;div id=&quot;map_address&quot; style=&quot;width: 500px; height: 500px; &quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;http://api.map.baidu.com/api?v=1.3&quot;&gt;&lt;/script&gt;&lt;script&gt;     var baidu_Point = new BMap.Point(104.066561,30.669561);  //经纬度坐标     var marker = new BMap.Marker(baidu_Point);               //标记     var pos_info = &quot;&lt;h5&gt;地点&lt;/h5&gt;&quot;                         +&quot;&lt;p style=&apos;font-size:12px;&apos;&gt;详细地址&lt;/p&gt;&quot;    var infoWindow = new BMap.InfoWindow(pos_info);          //信息展示    //地图初始化    var map = new BMap.Map(&quot;map_address&quot;);    map.centerAndZoom(baidu_Point, 20);//第二个参数指地图显示等级，数字越大显示越详细    map.addOverlay(marker);    map.openInfoWindow(infoWindow,baidu_Point);    map.addControl(new BMap.NavigationControl()); //控制工具    map.setCurrentCity(&quot;成都&quot;);                    // 设置地图显示的城市 此项是必须设置的    map.enableScrollWheelZoom(true);              //开启鼠标滚轮缩放&lt;/script&gt;</code></pre><p>以上就实现简单的调用，并显示在坐标处显示标志，如图</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img.blog.csdn.net/20160316195513509" alt="这里写图片描述" title="">                </div>                <div class="image-caption">这里写图片描述</div>            </figure><p>确实不难(毕竟不是自己实现-_-!)。</p><hr><p>第一次用肯定会遇到一些小问题的….<br>百度地图查询地址需要的地点坐标</p><pre><code>var baidu_Point = new BMap.Point(104.066561,30.669561);  //经纬度坐标</code></pre><p>如上，接收1个经纬度位置。其实也可以接收一个字符串，即查询地。比如</p><pre><code>var baidu_Point = new BMap.Point(&apos;成都市金牛区&apos;);  //地点字符串</code></pre><p>我在使用时地点太详细好像有点问题，最后使用经纬度查询。但开始没找到如何获取详细经纬度，所以只好找了google的地图获取了经纬度，但设置好后发现显示位置有偏差！看了 <a href="http://lbsyun.baidu.com/index.php?title=jspopular/guide/introduction" target="_blank" rel="external">官方介绍</a> ,才知道百度使用的坐标不是GPS坐标</p><blockquote><p>国际经纬度坐标标准为WGS-84,国内必须至少使用国测局制定的GCJ-02,对地理位置进行首次加密。百度坐标在此基础上，进行了BD-09二次加密措施,更加保护了个人隐私。百度对外接口的坐标系并不是GPS采集的真实经纬度，需要通过坐标转换接口进行转换。</p></blockquote><p>好吧，原来还要进行地址转换。</p><pre><code>//谷歌坐标var x = 116.32715863448607;var y = 39.990912172420714;var ggPoint = new BMap.Point(x,y);//地图初始化var bm = new BMap.Map(&quot;allmap&quot;);bm.centerAndZoom(ggPoint, 15);bm.addControl(new BMap.NavigationControl());    //坐标转换完之后的回调函数translateCallback = function (data){  if(data.status === 0) {       bm.setCenter(data.points[0]);  }}setTimeout(function(){    var convertor = new BMap.Convertor();    var pointArr = [];    pointArr.push(ggPoint);    convertor.translate(pointArr, 3, 5, translateCallback)}, 1000);</code></pre><p>以上是 <a href="http://developer.baidu.com/map/jsdemo.htm#a5_1" target="_blank" rel="external">官方demo</a> 代码，很简单。</p><hr><p>后来百度发现原来百度自己有 <a href="http://s.suixingpay.com/static/baiduMap/baiduMap.jsp" target="_blank" rel="external">坐标拾取器</a> -_-!用来直接获取经纬度，简直醉了，智商堪忧！<br>附一下<a href="http://developer.baidu.com/map/jsdemo.htm#a5_1" target="_blank" rel="external">百度地图API地址</a>，demo的代码很详细，复制粘贴就能直接使用。<br>虽然不难，学着用用总是好的，在此记录一下！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前几天被要求在页面中调用地图并显示指定地点位置。虽然之前没弄过，但觉的应该很简单，毕竟按着别人的API调用就好。&lt;br&gt;在国内google地图是用不了了，只能选了百度地图。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;首先需要引用百度地图的API&lt;br&gt;&lt;figure class=&quot;highl
      
    
    </summary>
    
    
      <category term="javascript" scheme="https://yguess.github.io/tags/javascript/"/>
    
  </entry>
  
</feed>
